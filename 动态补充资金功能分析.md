# 动态补充资金功能影响分析

## 功能概述

为回测任务增加动态补充资金功能：当触发买入信号但可用资金不足时，自动补充资金进行买入，补充的资金算作成本。

## 需要修改的核心模块

### 1. 配置层 (BacktestConfig)

**文件**: `backend/app/services/backtest/models/data_models.py`

**修改内容**:
- 添加 `enable_dynamic_capital_injection: bool = False` - 是否启用动态补充资金
- 添加 `max_capital_injection: Optional[float] = None` - 最大补充资金总额（None表示无限制）
- 添加 `capital_injection_cost_rate: float = 0.0` - 补充资金的成本率（如0.01表示1%的成本）

**影响**: 
- 所有创建 BacktestConfig 的地方需要适配新参数
- API 接口需要接收这些新参数

---

### 2. 组合管理器 (PortfolioManager)

**文件**: `backend/app/services/backtest/core/portfolio_manager.py`

#### 2.1 初始化修改

**需要添加的字段**:
```python
self.total_capital_injection = 0.0  # 累计补充资金总额
self.capital_injection_history: List[Dict[str, Any]] = []  # 补充资金历史记录
```

#### 2.2 `_execute_buy` 方法修改

**当前逻辑** (第94-211行):
- 计算可用资金
- 如果资金不足，返回失败

**修改后逻辑**:
```python
# 在资金不足检查处（约第128-129行）
if total_cost_with_commission > self.cash:
    # 如果启用了动态补充资金
    if self.config.enable_dynamic_capital_injection:
        # 计算需要补充的资金
        needed_cash = total_cost_with_commission - self.cash
        
        # 检查是否超过最大补充限制
        if self.config.max_capital_injection is not None:
            if self.total_capital_injection + needed_cash > self.config.max_capital_injection:
                return None, f"超过最大补充资金限制: 已补充 {self.total_capital_injection:.2f}, 需要 {needed_cash:.2f}, 限制 {self.config.max_capital_injection:.2f}"
        
        # 计算补充资金的成本
        injection_cost = needed_cash * self.config.capital_injection_cost_rate
        
        # 补充资金
        self.cash += needed_cash
        self.total_capital_injection += needed_cash
        
        # 记录补充资金历史
        self.capital_injection_history.append({
            'date': signal.timestamp,
            'amount': needed_cash,
            'cost': injection_cost,
            'reason': f'买入 {stock_code} 资金不足'
        })
        
        # 将补充资金成本计入总成本
        self.total_commission += injection_cost
        
        logger.info(f"动态补充资金: {needed_cash:.2f}, 成本: {injection_cost:.2f}, 用于买入 {stock_code}")
    else:
        # 未启用动态补充，返回失败
        return None, f"资金不足: 需要 {total_cost_with_commission:.2f}（含手续费 {commission:.2f}），可用 {self.cash:.2f}"
```

**影响**:
- 买入逻辑需要完全重写资金不足的处理
- 需要记录补充资金的历史

---

### 3. 指标计算影响分析

**文件**: `backend/app/services/backtest/core/portfolio_manager.py`

#### 3.1 `get_performance_metrics` 方法 (第319-382行)

**受影响的指标**:

1. **total_return (总收益率)**
   - **当前计算**: `(values[-1] - self.config.initial_cash) / self.config.initial_cash`
   - **问题**: 补充资金后，初始资金基准应该调整为 `initial_cash + total_capital_injection`
   - **修改**: 
     ```python
     total_invested = self.config.initial_cash + self.total_capital_injection
     total_return = (values[-1] - total_invested) / total_invested
     ```

2. **annualized_return (年化收益率)**
   - **影响**: 依赖 total_return，会自动受影响
   - **需要确认**: 是否需要调整基准

3. **sharpe_ratio (夏普比率)**
   - **影响**: 间接影响（通过收益率序列）
   - **需要确认**: 收益率序列计算是否需要调整

4. **max_drawdown (最大回撤)**
   - **当前计算**: 基于组合价值序列
   - **问题**: 补充资金后，回撤计算基准需要调整
   - **修改**: 需要考虑补充资金后的峰值计算
     ```python
     # 需要跟踪调整后的峰值（考虑补充资金）
     adjusted_peak = self.config.initial_cash
     for snapshot in self.portfolio_history:
         # 计算到当前快照时累计补充的资金
         cumulative_injection = sum([
             inj['amount'] for inj in self.capital_injection_history 
             if inj['date'] <= snapshot['date']
         ])
         adjusted_value = snapshot['portfolio_value'] - cumulative_injection
         if adjusted_value > adjusted_peak:
             adjusted_peak = adjusted_value
     ```

5. **成本统计**
   - **当前**: `total_commission`, `total_slippage`, `total_cost`
   - **修改**: 需要包含补充资金成本
     ```python
     'total_capital_injection': float(self.total_capital_injection),
     'capital_injection_cost': float(sum(inj['cost'] for inj in self.capital_injection_history)),
     'total_cost': float(self.total_commission + self.total_slippage + capital_injection_cost)
     ```

#### 3.2 `record_portfolio_snapshot` 方法 (第278-317行)

**需要添加**:
- 记录当前累计补充资金
- 记录调整后的组合价值（扣除补充资金）

```python
snapshot = {
    'date': date,
    'cash': self.cash,
    'portfolio_value': portfolio_value,
    'total_capital_injection': self.total_capital_injection,  # 新增
    'adjusted_portfolio_value': portfolio_value - self.total_capital_injection,  # 新增
    # ... 其他字段
}
```

---

### 4. 回测执行器 (BacktestExecutor)

**文件**: `backend/app/services/backtest/execution/backtest_executor.py`

#### 4.1 `_generate_backtest_report` 方法 (第737-854行)

**需要添加的字段**:
```python
report = {
    # ... 现有字段
    "capital_injection": {
        "enabled": config.enable_dynamic_capital_injection,
        "total_injection": portfolio_manager.total_capital_injection,
        "injection_cost": sum(inj['cost'] for inj in portfolio_manager.capital_injection_history),
        "injection_count": len(portfolio_manager.capital_injection_history),
        "injection_history": portfolio_manager.capital_injection_history
    },
    # ... 其他字段
}
```

#### 4.2 成本统计更新 (第824-830行)

需要包含补充资金成本：
```python
"cost_statistics": {
    "total_commission": portfolio_manager.total_commission,
    "total_slippage": portfolio_manager.total_slippage,
    "total_capital_injection": portfolio_manager.total_capital_injection,
    "capital_injection_cost": sum(inj['cost'] for inj in portfolio_manager.capital_injection_history),
    "total_cost": portfolio_manager.total_commission + portfolio_manager.total_slippage + capital_injection_cost,
    "cost_ratio": total_cost / (config.initial_cash + portfolio_manager.total_capital_injection)
}
```

---

### 5. API 接口层

#### 5.1 回测请求模型

**文件**: `backend/app/api/v1/schemas.py` 或相关文件

**需要添加字段**:
```python
class BacktestRequest(BaseModel):
    # ... 现有字段
    enable_dynamic_capital_injection: bool = False
    max_capital_injection: Optional[float] = None
    capital_injection_cost_rate: float = 0.0
```

#### 5.2 回测任务执行

**文件**: `backend/app/api/v1/backtest.py` 或 `backend/app/services/tasks/task_execution_engine.py`

**需要修改**: 创建 BacktestConfig 时传入新参数

---

### 6. 数据模型层（可选）

**文件**: `backend/app/models/backtest_detailed_models.py`

**可选添加**: `CapitalInjectionRecord` 表，用于持久化存储补充资金记录

```python
class CapitalInjectionRecord(Base):
    __tablename__ = "capital_injection_records"
    
    id = Column(Integer, primary_key=True)
    task_id = Column(String(50), nullable=False, index=True)
    backtest_id = Column(String(50), nullable=False, index=True)
    injection_date = Column(DateTime, nullable=False)
    amount = Column(Float, nullable=False)
    cost = Column(Float, nullable=False)
    reason = Column(Text, nullable=True)
    stock_code = Column(String(20), nullable=True)
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
```

---

### 7. 前端界面

#### 7.1 回测任务创建表单

**文件**: `frontend/src/app/tasks/create/page.tsx` 或相关组件

**需要添加**:
- 复选框：启用动态补充资金
- 输入框：最大补充资金（可选）
- 输入框：补充资金成本率

#### 7.2 回测结果展示

**文件**: `frontend/src/components/backtest/BacktestTaskStatus.tsx` 或相关组件

**需要显示**:
- 补充资金总额
- 补充资金成本
- 补充资金次数
- 补充资金历史记录（可选）

---

## 指标计算详细影响

### 需要调整的指标

| 指标 | 当前计算方式 | 调整后计算方式 | 影响程度 |
|------|------------|--------------|---------|
| **total_return** | `(final - initial) / initial` | `(final - total_invested) / total_invested` | ⚠️ **高** - 直接影响收益率 |
| **annualized_return** | 基于 total_return | 基于调整后的 total_return | ⚠️ **高** - 间接影响 |
| **sharpe_ratio** | 基于收益率序列 | 需要确认收益率序列计算 | ⚠️ **中** - 间接影响 |
| **max_drawdown** | 基于组合价值峰值 | 需要调整峰值计算（考虑补充资金） | ⚠️ **高** - 直接影响风险指标 |
| **volatility** | 基于收益率序列 | 需要确认收益率序列计算 | ⚠️ **中** - 间接影响 |
| **total_cost** | `commission + slippage` | `commission + slippage + injection_cost` | ⚠️ **高** - 直接影响成本统计 |
| **cost_ratio** | `total_cost / initial_cash` | `total_cost / total_invested` | ⚠️ **中** - 间接影响 |

### 不需要调整的指标

- **win_rate** - 基于交易盈亏，不受影响
- **profit_factor** - 基于交易盈亏，不受影响
- **winning_trades / losing_trades** - 基于交易记录，不受影响

---

## 实现步骤建议

### 阶段1: 核心功能实现
1. ✅ 修改 `BacktestConfig` 添加配置参数
2. ✅ 修改 `PortfolioManager` 实现动态补充资金逻辑
3. ✅ 调整 `get_performance_metrics` 中的指标计算
4. ✅ 更新 `record_portfolio_snapshot` 记录补充资金信息

### 阶段2: 报告和接口
5. ✅ 更新 `_generate_backtest_report` 包含补充资金信息
6. ✅ 修改 API 接口接收新参数
7. ✅ 更新任务执行引擎传递配置

### 阶段3: 前端界面
8. ✅ 添加配置选项到创建表单
9. ✅ 添加结果显示到结果页面

### 阶段4: 数据持久化（可选）
10. ⚪ 创建 `CapitalInjectionRecord` 数据模型
11. ⚪ 实现补充资金记录的持久化

---

## 注意事项

1. **向后兼容性**: 
   - 默认 `enable_dynamic_capital_injection = False`，确保现有回测不受影响

2. **性能影响**:
   - 补充资金历史记录会增加内存使用
   - 指标计算需要遍历补充资金历史，可能影响性能

3. **数据一致性**:
   - 确保补充资金成本正确计入总成本
   - 确保指标计算使用一致的基准

4. **测试覆盖**:
   - 测试启用/未启用动态补充资金的场景
   - 测试达到最大补充资金限制的场景
   - 测试补充资金成本计算
   - 测试指标计算的正确性

5. **用户体验**:
   - 在回测报告中清晰显示补充资金信息
   - 提供补充资金历史记录的查看功能
   - 在指标说明中解释补充资金的影响

---

## 总结

动态补充资金功能主要影响：

1. **配置层**: 添加3个新配置参数
2. **核心逻辑**: PortfolioManager 的买入逻辑和指标计算
3. **指标计算**: 7个指标需要调整，其中3个影响较大
4. **报告生成**: 需要添加补充资金相关信息
5. **API接口**: 需要接收和传递新参数
6. **前端界面**: 需要添加配置和显示功能

**关键修改点**:
- `PortfolioManager._execute_buy` - 核心逻辑
- `PortfolioManager.get_performance_metrics` - 指标计算
- `BacktestExecutor._generate_backtest_report` - 报告生成

**风险等级**: ⚠️ **中等** - 需要仔细测试指标计算的正确性
