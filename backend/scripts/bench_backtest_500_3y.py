#!/usr/bin/env python
"""Benchmark backtest wall-time and segment breakdown.

Acceptance entrypoint (Phase0/Phase1):
  backend/scripts/bench_backtest_500_3y.py

Goals:
- Print wall time + segment breakdown (load / precompute signals / main loop / metrics)
- Record timings for N in {10,50,100,500} (configurable)

Usage:
  cd backend
  ./venv/bin/python scripts/bench_backtest_500_3y.py --sizes 10,50,100 --start 2021-01-01 --end 2024-01-01

Notes:
- Uses RSI strategy by default (can switch via --strategy).
- Universe is deterministic: seed + optional universe file.
"""

from __future__ import annotations

import argparse
import asyncio
import os
import random
import sys
import time
from dataclasses import dataclass
from datetime import datetime
from typing import Iterable

BACKEND_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if BACKEND_ROOT not in sys.path:
    sys.path.insert(0, BACKEND_ROOT)

from app.core.config import settings
from app.services.backtest import BacktestExecutor
from app.services.backtest.models import BacktestConfig

# Reduce log noise during benchmark (loguru)
try:
    from loguru import logger as _logger

    _logger.remove()
    _logger.add(sys.stderr, level=os.environ.get("BENCH_LOG_LEVEL", "WARNING"))
except Exception:
    pass


def _list_codes() -> list[str]:
    data_root = str(settings.DATA_ROOT_PATH)
    qlib_day_dir = os.path.join(data_root, "qlib_data", "features", "day")
    codes: list[str] = []
    if os.path.isdir(qlib_day_dir):
        for name in os.listdir(qlib_day_dir):
            if name.endswith(".parquet"):
                codes.append(name.replace(".parquet", "").replace("_", "."))
    else:
        stock_parquet_dir = os.path.join(data_root, "parquet", "stock_data")
        if os.path.isdir(stock_parquet_dir):
            for name in os.listdir(stock_parquet_dir):
                if name.endswith(".parquet"):
                    codes.append(name.replace(".parquet", "").replace("_", "."))
    return sorted(set([c for c in codes if c]))


def _read_universe_file(path: str) -> list[str]:
    if not path:
        return []
    if not os.path.exists(path):
        return []
    out: list[str] = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            s = line.strip()
            if not s or s.startswith("#"):
                continue
            out.append(s)
    return out


def _write_universe_file(path: str, codes: Iterable[str]) -> None:
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write("# fixed universe generated by bench_backtest_500_3y.py\n")
        for c in codes:
            f.write(f"{c}\n")


@dataclass
class BenchRow:
    n: int
    wall_s: float
    load_s: float
    precompute_s: float
    align_s: float
    loop_s: float
    metrics_s: float


def _fmt(s: float) -> str:
    return f"{s:8.3f}"


async def _run_one(
    *,
    n: int,
    universe_codes: list[str],
    start_dt: datetime,
    end_dt: datetime,
    strategy_name: str,
    strategy_config: dict,
    max_workers: int | None,
) -> BenchRow:
    executor = BacktestExecutor(
        data_dir=str(settings.DATA_ROOT_PATH),
        enable_parallel=True,
        max_workers=max_workers,
        enable_performance_profiling=False,
        use_multiprocessing=False,
    )

    stock_codes = universe_codes[:n]

    t0 = time.perf_counter()
    res = await executor.run_backtest(
        strategy_name=strategy_name,
        stock_codes=stock_codes,
        start_date=start_dt,
        end_date=end_dt,
        strategy_config=strategy_config,
        backtest_config=BacktestConfig(
            record_portfolio_history=False,
            record_positions_in_history=False,
            portfolio_history_stride=20,
        ),
    )
    wall = time.perf_counter() - t0

    perf = res.get("perf_breakdown", {}) or {}

    return BenchRow(
        n=n,
        wall_s=wall,
        load_s=float(perf.get("data_loading_s", float("nan"))),
        precompute_s=float(perf.get("precompute_signals_s", float("nan"))),
        align_s=float(perf.get("align_arrays_s", float("nan"))),
        loop_s=float(perf.get("main_loop_s", float("nan"))),
        metrics_s=float(perf.get("metrics_s", float("nan"))),
    )


def _print_table(rows: list[BenchRow]) -> None:
    print("\n=== BENCH RESULT (seconds) ===")
    print("  N |    wall |    load | precomp |   align |    loop | metrics")
    print("----+---------+---------+---------+---------+---------+--------")
    for r in rows:
        print(
            f"{r.n:3d} |{_fmt(r.wall_s)} |{_fmt(r.load_s)} |{_fmt(r.precompute_s)} |{_fmt(r.align_s)} |{_fmt(r.loop_s)} |{_fmt(r.metrics_s)}"
        )


async def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--start", type=str, default=None, help="YYYY-MM-DD (default: now-3y)")
    ap.add_argument("--end", type=str, default=None, help="YYYY-MM-DD (default: today)")
    ap.add_argument("--sizes", type=str, default="10,50,100")
    ap.add_argument("--seed", type=int, default=42)

    ap.add_argument("--strategy", type=str, default="rsi")
    ap.add_argument(
        "--universe-file",
        type=str,
        default=os.path.join(BACKEND_ROOT, "data", "universe_500.txt"),
    )
    ap.add_argument(
        "--write-universe-file",
        action="store_true",
        help="If set and sizes include 500, generate & persist a fixed 500-code universe file.",
    )
    ap.add_argument("--max-workers", type=int, default=None)

    args = ap.parse_args()

    if args.end:
        end_dt = datetime.fromisoformat(args.end)
    else:
        end_dt = datetime.now()

    if args.start:
        start_dt = datetime.fromisoformat(args.start)
    else:
        # default: 3 years trailing window
        start_dt = end_dt.replace(year=end_dt.year - 3)

    # Universe selection
    sizes = [int(x) for x in args.sizes.split(",") if x.strip()]
    max_n = max(sizes)

    universe = _read_universe_file(args.universe_file)
    if universe:
        if len(universe) < max_n:
            raise SystemExit(
                f"Universe file has only {len(universe)} codes (< max_n={max_n}): {args.universe_file}"
            )
        universe_codes = universe
        print(f"[universe] from file: {args.universe_file} (codes={len(universe_codes)})")
    else:
        all_codes = _list_codes()
        if len(all_codes) < max_n:
            raise SystemExit(f"Not enough codes on disk: have={len(all_codes)} need={max_n}")

        rng = random.Random(int(args.seed))
        rng.shuffle(all_codes)
        universe_codes = all_codes[:max_n]
        print(f"[universe] from disk listing (codes={len(all_codes)}), selected={len(universe_codes)}")

        # Optionally persist a fixed 500 universe for reproducibility
        if args.write_universe_file and max_n >= 500:
            _write_universe_file(args.universe_file, universe_codes[:500])
            print(f"[universe] wrote fixed universe: {args.universe_file}")

    # Strategy
    if args.strategy.lower() == "rsi":
        strategy_name = "rsi"
        strategy_config = {
            "rsi_period": 14,
            "oversold_threshold": 30,
            "overbought_threshold": 70,
            # keep simplified switches stable
            "enable_trend_alignment": False,
            "enable_divergence": False,
            "enable_crossover": True,
        }
    else:
        # fall back to whatever strategy factory accepts
        strategy_name = args.strategy
        strategy_config = {}

    rows: list[BenchRow] = []
    for n in sizes:
        row = await _run_one(
            n=n,
            universe_codes=universe_codes,
            start_dt=start_dt,
            end_dt=end_dt,
            strategy_name=strategy_name,
            strategy_config=strategy_config,
            max_workers=args.max_workers,
        )
        rows.append(row)
        print(
            f"[done] n={n} wall={row.wall_s:.3f}s load={row.load_s:.3f}s precompute={row.precompute_s:.3f}s align={row.align_s:.3f}s loop={row.loop_s:.3f}s metrics={row.metrics_s:.3f}s"
        )

    _print_table(rows)


if __name__ == "__main__":
    asyncio.run(main())
