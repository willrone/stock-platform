# Phase 3 深度优化方案

## 目���
- **当前基线**：338.6秒（Phase 2）
- **目标耗时**：< 180秒
- **需要提升**：1.88倍

## 已知瓶颈分析

### 1. 主循环（212.03s, 71.74%）
**问题**：
- 逐日逐股的 Python 循环（500股 × 730天 = 365,000次迭代）
- 每次迭代都有 DataFrame 访问开销
- 大量的字典查找和条件判断

**优化方案**：
- ✅ 已有 `aligned_arrays`（NumPy 数组），但未充分利用
- 🎯 **优化 1**：向量化价格查找（批量处理所有股票）
- 🎯 **优化 2**：向量化信号执行（批量处理买卖信号）
- 🎯 **优化 3**：使用 Numba JIT 编译核心循环

### 2. 信号预计算（74.93s, 25.36%）
**问题**：
- 虽然已经向量化，但仍然是串行处理每只股票
- RSI 计算涉及大量 rolling 操作

**优化方案**：
- 🎯 **优化 4**：使用 Numba 加速 RSI 计算
- 🎯 **优化 5**：真正的多进程并行（已有代码但未启用）

### 3. 数组对齐（44.53s, 15.07%）
**问题**：
- 需要将 DataFrame 转换为 NumPy 数组
- 涉及大量的 reindex 操作

**优化方案**：
- 🎯 **优化 6**：缓存对齐结果，避免重复计算
- 🎯 **优化 7**：使用更高效的数组填充方法

## 优化实施顺序

### Phase 3.1: Numba 加速 RSI 计算（预期 -30~50s）
**优先级**：⭐⭐⭐⭐⭐
**原因**：
- RSI 计算是纯数值计算，非常适合 Numba
- 代码改动小，风险低
- 效果立竿见影

**实施步骤**：
1. 创建 `numba_indicators.py`（已存在，需增强）
2. 实现 `@njit` 版本的 RSI 计算
3. 在 `RSIStrategy` 中使用 Numba 版本
4. 测试验证结果一致性

### Phase 3.2: 主循环向量化（预期 -80~120s）
**优先级**：⭐⭐⭐⭐⭐
**原因**：
- 主循环是最大瓶颈（71.74%）
- 已有 `aligned_arrays`，只需改造循环逻辑

**实施步骤**：
1. 创建向量化的交易执行函数
2. 批量处理买入/卖出信号
3. 使用 NumPy 广播避免循环
4. 保持结果一致性

### Phase 3.3: 多进程信号预计算（预期 -20~30s）
**优先级**：⭐⭐⭐
**原因**：
- 代码已存在，只需启用
- 可突破 GIL 限制

**实施步骤**：
1. 启用 `use_multiprocessing=True`
2. 优化序列化开销
3. 测试稳定性

### Phase 3.4: 数组对齐优化（预期 -10~20s）
**优先级**：⭐⭐
**原因**：
- 相对次要瓶颈
- 优化空间有限

**实施步骤**：
1. 缓存对齐结果
2. 使用 `np.searchsorted` 加速日期查找
3. 预分配数组避免动态扩展

## 风险控制

### 验证标准
- ✅ 总收益率：39.55% ± 2%
- ✅ 交易数量：与基线一致
- ✅ 最终持仓：与基线一致

### 回滚策略
- 每个优化独立提交
- 保留原始代码作为 fallback
- 使用 feature flag 控制启用/禁用

## 预期结果

| 优化项 | 预期节省 | 累计耗时 | 进度 |
|--------|---------|---------|------|
| 基线 | - | 338.6s | - |
| Numba RSI | -40s | 298.6s | 11.8% |
| 主循环向量化 | -100s | 198.6s | 41.3% |
| 多进程预计算 | -25s | 173.6s | 48.7% |
| 数组对齐优化 | -15s | 158.6s | 53.2% |

**最终目标**：< 180秒 ✅
**实际预期**：~160秒（留有余量）
